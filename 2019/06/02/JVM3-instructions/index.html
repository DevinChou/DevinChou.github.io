<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      JVM实现(三)-指令集 | Rousseau Chou&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zhou Hangqi">
    
    

    <meta name="description" content="3.1 指令集每条指令都以一个单字节的操作码(opcode)开头，java虚拟机最多支持256条指令。至JDK1.8，Java虚拟机规范已定义了205条指令，分别是0(0x00)到202(OxCA),204(0xFE)和255(0xFF)。Java虚拟机使用变长指令，操作码后面可以跟零字节或多字节的操作数(operand)。
由于操作数栈和局部变量表只存放数据的值，并不记录数据类型，因此指令必须知">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM实现(三)-指令集 | Rousseau Chou's Blog">
<meta property="og:url" content="http://yoursite.com/2019/06/02/JVM3-instructions/index.html">
<meta property="og:site_name" content="Rousseau Chou's Blog">
<meta property="og:description" content="3.1 指令集每条指令都以一个单字节的操作码(opcode)开头，java虚拟机最多支持256条指令。至JDK1.8，Java虚拟机规范已定义了205条指令，分别是0(0x00)到202(OxCA),204(0xFE)和255(0xFF)。Java虚拟机使用变长指令，操作码后面可以跟零字节或多字节的操作数(operand)。
由于操作数栈和局部变量表只存放数据的值，并不记录数据类型，因此指令必须知">
<meta property="og:updated_time" content="2019-07-21T19:24:25.934Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM实现(三)-指令集 | Rousseau Chou's Blog">
<meta name="twitter:description" content="3.1 指令集每条指令都以一个单字节的操作码(opcode)开头，java虚拟机最多支持256条指令。至JDK1.8，Java虚拟机规范已定义了205条指令，分别是0(0x00)到202(OxCA),204(0xFE)和255(0xFF)。Java虚拟机使用变长指令，操作码后面可以跟零字节或多字节的操作数(operand)。
由于操作数栈和局部变量表只存放数据的值，并不记录数据类型，因此指令必须知">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Rousseau Chou&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          These violent delights have violent ends.
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">home</a></li>
              
                
                <li class="navigation__item"><a href="/categories/code" title="" class="">code</a></li>
              
                
                <li class="navigation__item"><a href="/categories/peruse" title="" class="">peruse</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">about</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">JVM实现(三)-指令集</h1>

    

    <div class="post-meta">
      <time datetime="2019-06-02" class="post-meta__date date">2019-06-02</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/code/">code</a>
            </font>
          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h4 id="3-1-指令集"><a href="#3-1-指令集" class="headerlink" title="3.1 指令集"></a>3.1 指令集</h4><p>每条指令都以一个单字节的操作码(opcode)开头，java虚拟机最多支持256条指令。至JDK1.8，Java虚拟机规范已定义了205条指令，分别是0(0x00)到202(OxCA),204(0xFE)和255(0xFF)。<br>Java虚拟机使用变长指令，操作码后面可以跟零字节或多字节的操作数(operand)。</p>
<p>由于操作数栈和局部变量表只存放数据的值，并不记录数据类型，因此指令必须知道自己在操作什么类型的数据。例如iadd指令就是对int类型进行加法操作，dstore指令把操作数栈顶的double类型弹出储存到局部变量表。</p>
<table>
<thead>
<tr>
<th>助记符首字母</th>
<th>数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>reference</td>
</tr>
<tr>
<td>b</td>
<td>byte/boolean</td>
</tr>
<tr>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
</tr>
<tr>
<td>f</td>
<td>float</td>
</tr>
<tr>
<td>i</td>
<td>int</td>
</tr>
<tr>
<td>l</td>
<td>long</td>
</tr>
<tr>
<td>s</td>
<td>short</td>
</tr>
</tbody>
</table>
<p>Java虚拟机规范将已定义的205条指令分为11类<br>常量(constants)，加载(loads)，存储(stores)，操作数栈(stack)，数学(math)，转换(conversions)，比较(comparisons)，控制(control)，引用(references)，扩展(extended)和保留(reserved)。</p>
<h4 id="3-2-指令基础实现"><a href="#3-2-指令基础实现" class="headerlink" title="3.2 指令基础实现"></a>3.2 指令基础实现</h4><p>指令接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type Instruction interface &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	   提取操作数</div><div class="line">	 */</div><div class="line">	FetchOperands(reader *ByteCodeReader)</div><div class="line"></div><div class="line">	/**</div><div class="line">	   执行指令逻辑</div><div class="line">	 */</div><div class="line">	Execute(frame *rtda.Frame)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无操作数指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type NoOperandsInstruction struct &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *NoOperandsInstruction) FetchOperands(reader *ByteCodeReader) &#123;</div><div class="line">	// nothing to do</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跳转指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type BranchInstruction struct &#123;</div><div class="line">	Offset int // 跳转偏移量</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *BranchInstruction) FetchOperands(reader *ByteCodeReader) &#123;</div><div class="line">	self.Offset = int(reader.ReadInt16())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>存储和加载类指令需要根据索引存取局部变量表，索引由单字节操作数给出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type Index8Instruction struct &#123;</div><div class="line">	Index uint // 局部变量表索引</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *Index8Instruction) FetchOperands(reader *ByteCodeReader) &#123;</div><div class="line">	self.Index = uint(reader.ReadUint8())</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有一些指令需要访问运行时常量池，常量池索引由两字节操作数给出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type Index16Instruction struct &#123;</div><div class="line">	Index uint // 局部变量表索引</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *Index16Instruction) FetchOperands(reader *ByteCodeReader) &#123;</div><div class="line">	self.Index = uint(reader.ReadUint16())</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-3-constants指令"><a href="#3-3-constants指令" class="headerlink" title="3.3 constants指令"></a>3.3 constants指令</h4><p>3.3.1 nop指令。</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>nop</td>
<td>什么也不做</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type NOP struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *NOP) Execute(frame *rtda.Frame)  &#123;</div><div class="line">  // nothing to do</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.3.2 const系列指令。把在操作码中的常量值推入操作数栈顶，共15条指令。</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x01</td>
<td>aconst_null</td>
<td>把null引用推入栈</td>
</tr>
<tr>
<td>0x02</td>
<td>iconst_m1</td>
<td>int型常量值-1进栈  </td>
</tr>
<tr>
<td>0x03</td>
<td>iconst_0</td>
<td>int型常量值0进栈  </td>
</tr>
<tr>
<td>0x04</td>
<td>iconst_1</td>
<td>int型常量值1进栈  </td>
</tr>
<tr>
<td>0x05</td>
<td>iconst_2</td>
<td>int型常量值2进栈  </td>
</tr>
<tr>
<td>0x06</td>
<td>iconst_3</td>
<td>int型常量值3进栈  </td>
</tr>
<tr>
<td>0x07</td>
<td>iconst_4</td>
<td>int型常量值4进栈  </td>
</tr>
<tr>
<td>0x08</td>
<td>iconst_5</td>
<td>int型常量值5进栈  </td>
</tr>
<tr>
<td>0x09</td>
<td>lconst_0</td>
<td>long型常量值0进栈  </td>
</tr>
<tr>
<td>0x0A</td>
<td>lconst_1</td>
<td>long型常量值1进栈  </td>
</tr>
<tr>
<td>0x0B</td>
<td>fconst_0</td>
<td>float型常量值0进栈  </td>
</tr>
<tr>
<td>0x0C</td>
<td>fconst_1</td>
<td>float型常量值1进栈  </td>
</tr>
<tr>
<td>0x0D</td>
<td>fconst_2</td>
<td>float型常量值2进栈  </td>
</tr>
<tr>
<td>0x0E</td>
<td>dconst_0</td>
<td>double型常量值0进栈  </td>
</tr>
<tr>
<td>0x0F</td>
<td>dconst_1</td>
<td>double型常量值1进栈  </td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type ACONST_NULL struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *ACONST_NULL) Execute(frame *rtda.Frame) &#123;</div><div class="line">	frame.OperandStack().PushRef(nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.3.3 ipush指令。从操作数获取一个byte类型或short类型，扩展成int类型，推入栈顶。</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x10</td>
<td>bipush</td>
<td>将一个byte型常量值推送至栈顶</td>
</tr>
<tr>
<td>0x11</td>
<td>sipush</td>
<td>将一个short型常量值推送至栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type BIPUSH struct &#123;</div><div class="line">	val int8</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *BIPUSH) FetchOperands(reader *base.ByteCodeReader) &#123;</div><div class="line">	self.val = reader.ReadInt8()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *BIPUSH) Execute(frame *rtda.Frame) &#123;</div><div class="line">	frame.OperandStack().PushInt(int32(self.val))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.3.4 ldc指令。将int,float或String,long或double型常量值从常量池中推送至栈顶.</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x12</td>
<td>ldc</td>
<td>将int、float或String型常量值从常量池中推送至栈顶</td>
</tr>
<tr>
<td>0x13</td>
<td>ldc_w</td>
<td>将int、float或String型常量值从常量池中推送至栈顶（宽索引）</td>
</tr>
<tr>
<td>0x14</td>
<td>ldc2_w</td>
<td>将long或double型常量值从常量池中推送至栈顶（宽索引）</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">type LDC_W struct &#123;</div><div class="line">	base.Index16Instruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *LDC_W) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	class := frame.Method().Class()</div><div class="line">	c := class.ConstantPool().GetConstant(index)</div><div class="line"></div><div class="line">	switch c.(type) &#123;</div><div class="line">	case int32:</div><div class="line">		stack.PushInt(c.(int32))</div><div class="line">	case float32:</div><div class="line">		stack.PushFloat(c.(float32))</div><div class="line">	case string:</div><div class="line">		internedStr := heap.JString(class.Loader(), c.(string))</div><div class="line">		stack.PushRef(internedStr)</div><div class="line">	case *heap.ClassRef:</div><div class="line">		classRef := c.(*heap.ClassRef)</div><div class="line">		classObj := classRef.ResolvedClass().JClass()</div><div class="line">		stack.PushRef(classObj)</div><div class="line">		// case MethodType, MethodHandle</div><div class="line">	default:</div><div class="line">		panic(&quot;todo: ldc!&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-5-加载指令"><a href="#3-5-加载指令" class="headerlink" title="3.5 加载指令"></a>3.5 加载指令</h4><p>加载指令从局部变量表获取变量，然后推入操作数栈，共33条。<br>3.5.1 load系列</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x15</td>
<td>iload</td>
<td>指定的int局部变量进栈</td>
</tr>
<tr>
<td>0x16</td>
<td>lload</td>
<td>指定的long局部变量进栈</td>
</tr>
<tr>
<td>0x17</td>
<td>fload</td>
<td>指定的float局部变量进栈</td>
</tr>
<tr>
<td>0x18</td>
<td>dload</td>
<td>指定的double局部变量进栈</td>
</tr>
<tr>
<td>0x19</td>
<td>aload</td>
<td>指定的引用局部变量进栈</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type ILOAD struct &#123;</div><div class="line">	base.Index8Instruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *ILOAD) Execute(frame *rtda.Frame) &#123;</div><div class="line">	val := frame.LocalVars().GetInt(index)</div><div class="line">	frame.OperandStack().PushInt(val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.5.2 load_x系列</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x1A</td>
<td>iload_0</td>
<td>第一个int局部变量进栈</td>
</tr>
<tr>
<td>0x1B</td>
<td>iload_1</td>
<td>第二个int局部变量进栈</td>
</tr>
<tr>
<td>0x1C</td>
<td>iload_2</td>
<td>第三个int局部变量进栈</td>
</tr>
<tr>
<td>0x1D</td>
<td>iload_3</td>
<td>第四个int局部变量进栈</td>
</tr>
<tr>
<td>0x1E</td>
<td>lload_0</td>
<td>第一个long局部变量进栈</td>
</tr>
<tr>
<td>0x1F</td>
<td>lload_1</td>
<td>第二个long局部变量进栈</td>
</tr>
<tr>
<td>0x20</td>
<td>lload_2</td>
<td>第三个long局部变量进栈</td>
</tr>
<tr>
<td>0x21</td>
<td>lload_3</td>
<td>第四个long局部变量进栈</td>
</tr>
<tr>
<td>0x22</td>
<td>fload_0</td>
<td>第一个float局部变量进栈</td>
</tr>
<tr>
<td>0x23</td>
<td>fload_1</td>
<td>第二个float局部变量进栈</td>
</tr>
<tr>
<td>0x24</td>
<td>fload_2</td>
<td>第三个float局部变量进栈</td>
</tr>
<tr>
<td>0x25</td>
<td>fload_3</td>
<td>第四个float局部变量进栈</td>
</tr>
<tr>
<td>0x26</td>
<td>dload_0</td>
<td>第一个double局部变量进栈</td>
</tr>
<tr>
<td>0x27</td>
<td>dload_1</td>
<td>第二个double局部变量进栈</td>
</tr>
<tr>
<td>0x28</td>
<td>dload_2</td>
<td>第三个double局部变量进栈</td>
</tr>
<tr>
<td>0x29</td>
<td>dload_3</td>
<td>第四个double局部变量进栈</td>
</tr>
<tr>
<td>0x2A</td>
<td>aload_0</td>
<td>第一个引用局部变量进栈</td>
</tr>
<tr>
<td>0x2B</td>
<td>aload_1</td>
<td>第二个引用局部变量进栈</td>
</tr>
<tr>
<td>0x2C</td>
<td>aload_2</td>
<td>第三个引用局部变量进栈</td>
</tr>
<tr>
<td>0x2D</td>
<td>aload_3</td>
<td>第四个引用局部变量进栈</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type ILOAD_0 struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *ILOAD_0) Execute(frame *rtda.Frame) &#123;</div><div class="line">	val := frame.LocalVars().GetInt(0)</div><div class="line">	frame.OperandStack().PushInt(val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.5.3 xaload系列。将指定的x类型数组的指定下标处的值推入操作数栈。</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2E</td>
<td>iaload</td>
<td>指定的int型数组的指定下标处的值进栈</td>
</tr>
<tr>
<td>0x2F</td>
<td>laload</td>
<td>指定的long型数组的指定下标处的值进栈</td>
</tr>
<tr>
<td>0x30</td>
<td>faload</td>
<td>指定的float型数组的指定下标处的值进栈</td>
</tr>
<tr>
<td>0x31</td>
<td>daload</td>
<td>指定的double型数组的指定下标处的值进栈</td>
</tr>
<tr>
<td>0x32</td>
<td>aaload</td>
<td>指定的引用型数组的指定下标处的值进栈</td>
</tr>
<tr>
<td>0x33</td>
<td>baload</td>
<td>指定的boolean或byte型数组的指定下标处的值进栈</td>
</tr>
<tr>
<td>0x34</td>
<td>caload</td>
<td>指定的char型数组的指定下标处的值进栈</td>
</tr>
<tr>
<td>0x35</td>
<td>saload</td>
<td>指定的short型数组的指定下标处的值进栈</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">type AALOAD struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *AALOAD) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	index := stack.PopInt()</div><div class="line">	arrRef := stack.PopRef()</div><div class="line"></div><div class="line">	checkNotNil(arrRef) //如果为空抛出NullPointerException</div><div class="line">	refs := arrRef.Refs()</div><div class="line">	checkIndex(len(refs), index) //如果超出数组长度抛出ArrayIndexOutOfBoundsException</div><div class="line">	stack.PushRef(refs[index])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-6-存储指令"><a href="#3-6-存储指令" class="headerlink" title="3.6 存储指令"></a>3.6 存储指令</h4><p>和加载指令相反，存储指令把变量从操作数栈顶弹出，然后存入局部变量表。<br>3.6.1 store系列</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x36</td>
<td>istore</td>
<td>将栈顶int型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x37</td>
<td>lstore</td>
<td>将栈顶long型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x38</td>
<td>fstore</td>
<td>将栈顶float型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x39</td>
<td>dstore</td>
<td>将栈顶double型数值存入指定本地变量</td>
</tr>
<tr>
<td>0x3a</td>
<td>astore</td>
<td>将栈顶引用型数值存入指定本地变量</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type ISTORE struct &#123;</div><div class="line">	base.Index8Instruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *ISTORE) Execute(frame *rtda.Frame) &#123;</div><div class="line">	val := frame.OperandStack().PopInt()</div><div class="line">	frame.LocalVars().SetInt(uint(self.index), val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.6.2 store_x系列</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3b</td>
<td>istore_0</td>
<td>将栈顶int型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x3c</td>
<td>istore_1</td>
<td>将栈顶int型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x3d</td>
<td>istore_2</td>
<td>将栈顶int型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x3e</td>
<td>istore_3</td>
<td>将栈顶int型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x3f</td>
<td>lstore_0</td>
<td>将栈顶long型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x40</td>
<td>lstore_1</td>
<td>将栈顶long型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x41</td>
<td>lstore_2</td>
<td>将栈顶long型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x42</td>
<td>lstore_3</td>
<td>将栈顶long型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x43</td>
<td>fstore_0</td>
<td>将栈顶float型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x44</td>
<td>fstore_1</td>
<td>将栈顶float型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x45</td>
<td>fstore_2</td>
<td>将栈顶float型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x46</td>
<td>fstore_3</td>
<td>将栈顶float型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x47</td>
<td>dstore_0</td>
<td>将栈顶double型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x48</td>
<td>dstore_1</td>
<td>将栈顶double型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x49</td>
<td>dstore_2</td>
<td>将栈顶double型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x4a</td>
<td>dstore_3</td>
<td>将栈顶double型数值存入第四个本地变量</td>
</tr>
<tr>
<td>0x4b</td>
<td>astore_0</td>
<td>将栈顶引用型数值存入第一个本地变量</td>
</tr>
<tr>
<td>0x4c</td>
<td>astore_1</td>
<td>将栈顶引用型数值存入第二个本地变量</td>
</tr>
<tr>
<td>0x4d</td>
<td>astore_2</td>
<td>将栈顶引用型数值存入第三个本地变量</td>
</tr>
<tr>
<td>0x4e</td>
<td>astore_3</td>
<td>将栈顶引用型数值存入第四个本地变量</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type ISTORE_0 struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *ISTORE_0) Execute(frame *rtda.Frame) &#123;</div><div class="line">	val := frame.OperandStack().PopInt()</div><div class="line">	frame.LocalVars().SetInt(0, val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.6.3 xastore系列</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4f</td>
<td>iastore</td>
<td>将栈顶int型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x50</td>
<td>lastore</td>
<td>将栈顶long型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x51</td>
<td>fastore</td>
<td>将栈顶float型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x52</td>
<td>dastore</td>
<td>将栈顶double型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x53</td>
<td>aastore</td>
<td>将栈顶引用型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x54</td>
<td>bastore</td>
<td>将栈顶boolean或byte型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x55</td>
<td>castore</td>
<td>将栈顶char型数值存入指定数组的指定索引位置</td>
</tr>
<tr>
<td>0x56</td>
<td>sastore</td>
<td>将栈顶short型数值存入指定数组的指定索引位置</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type AASTORE struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *AASTORE) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	ref := stack.PopRef()</div><div class="line">	index := stack.PopInt()</div><div class="line">	arrRef := stack.PopRef()</div><div class="line"></div><div class="line">	checkNotNil(arrRef)</div><div class="line">	refs := arrRef.Refs()</div><div class="line">	checkIndex(len(refs), index)</div><div class="line">	refs[index] = ref</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-7-栈指令"><a href="#3-7-栈指令" class="headerlink" title="3.7 栈指令"></a>3.7 栈指令</h4><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x57</td>
<td>pop</td>
<td>将栈顶数值弹出 (数值不能是long或double类型的)</td>
</tr>
<tr>
<td>0x58</td>
<td>pop2</td>
<td>将栈顶的一个（long或double类型的)或两个数值弹出（其它）</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type POP struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *POP) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	stack.PopSlot() // pop2弹出2次</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x59</td>
<td>dup</td>
<td>复制栈顶数值并将复制值压入栈顶</td>
</tr>
<tr>
<td>0x5a</td>
<td>dup_x1</td>
<td>[…][c][b][a] -&gt; […][c][a][b][a]</td>
</tr>
<tr>
<td>0x5b</td>
<td>dup_x2</td>
<td>[…][c][b][a] -&gt; […][a][c][b][a]</td>
</tr>
<tr>
<td>0x5c</td>
<td>dup2</td>
<td>[…][c][b][a] -&gt; […][c][b][a][b][a]</td>
</tr>
<tr>
<td>0x5d</td>
<td>dup2_x1</td>
<td>[…][c][b][a] -&gt; […][b][a][c][b][a]</td>
</tr>
<tr>
<td>0x5e</td>
<td>dup2_x2</td>
<td>[…][d][c][b][a] -&gt; […][b][a][d][c][b][a]</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">type DUP struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">bottom -&gt; top</div><div class="line">[...][c][b][a] -&gt; [...][c][b][a][a]</div><div class="line">*/</div><div class="line">func (self *DUP) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	slot := stack.PopSlot()</div><div class="line">	stack.PushSlot(slot)</div><div class="line">	stack.PushSlot(slot)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x5f</td>
<td>swap</td>
<td>将栈最顶端的两个数值互换(数值不能是long或double类型的)</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type SWAP struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *SWAP) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	slot1 := stack.PopSlot()</div><div class="line">	slot2 := stack.PopSlot()</div><div class="line">	stack.PushSlot(slot1)</div><div class="line">	stack.PushSlot(slot2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-8-数学指令"><a href="#3-8-数学指令" class="headerlink" title="3.8 数学指令"></a>3.8 数学指令</h4><p>3.8.1 算术指令</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x60</td>
<td>iadd</td>
<td>将栈顶两int型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x61</td>
<td>ladd</td>
<td>将栈顶两long型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x62</td>
<td>fadd</td>
<td>将栈顶两float型数值相加并将结果压入栈顶</td>
</tr>
<tr>
<td>0x63</td>
<td>dadd</td>
<td>将栈顶两double型数值相加并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type IADD struct&#123; base.NoOperandsInstruction &#125;</div><div class="line"></div><div class="line">func (self *IADD) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	result := v1 + v2</div><div class="line">	stack.PushInt(result)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x64</td>
<td>isub</td>
<td>将栈顶两int型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x65</td>
<td>lsub</td>
<td>将栈顶两long型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x66</td>
<td>fsub</td>
<td>将栈顶两float型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>0x67</td>
<td>dsub</td>
<td>将栈顶两double型数值相减并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type ISUB struct&#123; base.NoOperandsInstruction &#125;</div><div class="line"></div><div class="line">func (self *ISUB) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	result := v1 - v2</div><div class="line">	stack.PushInt(result)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x68</td>
<td>imul</td>
<td>将栈顶两int型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x69</td>
<td>lmul</td>
<td>将栈顶两long型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6a</td>
<td>fmul</td>
<td>将栈顶两float型数值相乘并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6b</td>
<td>dmul</td>
<td>将栈顶两double型数值相乘并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type IMUL struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IMUL) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	result := v1 * v2</div><div class="line">	stack.PushInt(result)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x6c</td>
<td>idiv</td>
<td>将栈顶两int型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6d</td>
<td>ldiv</td>
<td>将栈顶两long型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6e</td>
<td>fdiv</td>
<td>将栈顶两float型数值相除并将结果压入栈顶</td>
</tr>
<tr>
<td>0x6f</td>
<td>ddiv</td>
<td>将栈顶两double型数值相除并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type IDIV struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IDIV) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	if v2 == 0 &#123;</div><div class="line">		panic(&quot;java.lang.ArithmeticException: / by zero&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	result := v1 / v2</div><div class="line">	stack.PushInt(result)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x70</td>
<td>irem</td>
<td>将栈顶两int型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x71</td>
<td>lrem</td>
<td>将栈顶两long型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x72</td>
<td>frem</td>
<td>将栈顶两float型数值作取模运算并将结果压入栈顶</td>
</tr>
<tr>
<td>0x73</td>
<td>drem</td>
<td>将栈顶两double型数值作取模运算并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">type IREM struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IREM) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	if v2 == 0 &#123;</div><div class="line">		panic(&quot;java.lang.ArithmeticException: / by zero&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	result := v1 % v2</div><div class="line">	stack.PushInt(result)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x74</td>
<td>ineg</td>
<td>将栈顶int型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x75</td>
<td>lneg</td>
<td>将栈顶long型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x76</td>
<td>fneg</td>
<td>将栈顶float型数值取负并将结果压入栈顶</td>
</tr>
<tr>
<td>0x77</td>
<td>dneg</td>
<td>将栈顶double型数值取负并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type INEG struct&#123; base.NoOperandsInstruction &#125;</div><div class="line"></div><div class="line">func (self *INEG) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	val := stack.PopInt()</div><div class="line">	stack.PushInt(-val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.8.2 位移指令</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x78</td>
<td>ishl</td>
<td>将int型数值左移位指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x79</td>
<td>lshl</td>
<td>将long型数值左移位指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7a</td>
<td>ishr</td>
<td>将int型数值右（符号）移位指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7b</td>
<td>lshr</td>
<td>将long型数值右（符号）移位指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7c</td>
<td>iushr</td>
<td>将int型数值右（无符号）移位指定位数并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7d</td>
<td>lushr</td>
<td>将long型数值右（无符号）移位指定位数并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type ISHL struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *ISHL) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	s := uint32(v2) &amp; 0x1f // int变量只有32位，取末5位即可</div><div class="line">	stack.PushInt(v1 &lt;&lt; s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.8.3 布尔运算指令</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x7e</td>
<td>iand</td>
<td>将栈顶两int型数值作“按位与”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x7f</td>
<td>land</td>
<td>将栈顶两long型数值作“按位与”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x80</td>
<td>ior</td>
<td>将栈顶两int型数值作“按位或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x81</td>
<td>lor</td>
<td>将栈顶两long型数值作“按位或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x82</td>
<td>ixor</td>
<td>将栈顶两int型数值作“按位异或”并将结果压入栈顶</td>
</tr>
<tr>
<td>0x83</td>
<td>lxor</td>
<td>将栈顶两long型数值作“按位异或”并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type IAND struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IAND) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	result := v1 &amp;v2</div><div class="line">	stack.PushInt(result)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.8.4 自增自减指令</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x84</td>
<td>iinc</td>
<td>将指定int型变量增加指定值（i++, i–, i+=2）</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">type IINC struct &#123;</div><div class="line">	Index uint</div><div class="line">	Const int32</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IINC) FetchOperands(reader *base.ByteCodeReader) &#123;</div><div class="line">	self.Index = uint(reader.ReadUint8())</div><div class="line">	self.Const = int32(reader.ReadInt8())</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IINC) Execute(frame *rtda.Frame) &#123;</div><div class="line">	localVars := frame.LocalVars()</div><div class="line">	val := localVars.GetInt(self.Index)</div><div class="line">	val += self.Const</div><div class="line">	localVars.SetInt(self.Index, val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-9-类型转换指令"><a href="#3-9-类型转换指令" class="headerlink" title="3.9 类型转换指令"></a>3.9 类型转换指令</h4><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x85</td>
<td>i2l</td>
<td>将栈顶int型数值强制转换成long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x86</td>
<td>i2f</td>
<td>将栈顶int型数值强制转换成float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x87</td>
<td>i2d</td>
<td>将栈顶int型数值强制转换成double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x88</td>
<td>l2i</td>
<td>将栈顶long型数值强制转换成int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x89</td>
<td>l2f</td>
<td>将栈顶long型数值强制转换成float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8a</td>
<td>l2d</td>
<td>将栈顶long型数值强制转换成double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8b</td>
<td>f2i</td>
<td>将栈顶float型数值强制转换成int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8c</td>
<td>f2l</td>
<td>将栈顶float型数值强制转换成long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8d</td>
<td>f2d</td>
<td>将栈顶float型数值强制转换成double型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8e</td>
<td>d2i</td>
<td>将栈顶double型数值强制转换成int型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x8f</td>
<td>d2l</td>
<td>将栈顶double型数值强制转换成long型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x90</td>
<td>d2f</td>
<td>将栈顶double型数值强制转换成float型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x91</td>
<td>i2b</td>
<td>将栈顶int型数值强制转换成byte型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x92</td>
<td>i2c</td>
<td>将栈顶int型数值强制转换成char型数值并将结果压入栈顶</td>
</tr>
<tr>
<td>0x93</td>
<td>i2s</td>
<td>将栈顶int型数值强制转换成short型数值并将结果压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type I2L struct&#123; base.NoOperandsInstruction &#125;</div><div class="line"></div><div class="line">func (self *I2L) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	i := stack.PopInt()</div><div class="line">	l := int64(i)</div><div class="line">	stack.PushLong(l)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-10-比较指令"><a href="#3-10-比较指令" class="headerlink" title="3.10 比较指令"></a>3.10 比较指令</h4><h5 id="3-10-1-lcmp指令"><a href="#3-10-1-lcmp指令" class="headerlink" title="3.10.1 lcmp指令"></a>3.10.1 lcmp指令</h5><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x94</td>
<td>lcmp</td>
<td>比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">type LCMP struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *LCMP) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopLong()</div><div class="line">	v1 := stack.PopLong()</div><div class="line">	if v1 &gt; v2 &#123;</div><div class="line">		stack.PushInt(1)</div><div class="line">	&#125; else if v1 == v2 &#123;</div><div class="line">		stack.PushInt(0)</div><div class="line">	&#125; else &#123;</div><div class="line">		stack.PushInt(-1)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-10-2-fcmp和dcmp指令"><a href="#3-10-2-fcmp和dcmp指令" class="headerlink" title="3.10.2 fcmp和dcmp指令"></a>3.10.2 fcmp<op>和dcmp<op>指令</op></op></h5><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x95</td>
<td>fcmpl</td>
<td>比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶</td>
</tr>
<tr>
<td>0x96</td>
<td>fcmpg</td>
<td>比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶</td>
</tr>
<tr>
<td>0x97</td>
<td>dcmpl</td>
<td>比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶</td>
</tr>
<tr>
<td>0x98</td>
<td>dcmpg</td>
<td>比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">type FCMPL struct &#123;</div><div class="line">	base.NoOperandsInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *FCMPL) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopFloat()</div><div class="line">	v1 := stack.PopFloat()</div><div class="line">	if v1 &gt; v2 &#123;</div><div class="line">		stack.PushInt(1)</div><div class="line">	&#125; else if v1 == v2 &#123;</div><div class="line">		stack.PushInt(0)</div><div class="line">	&#125; else if v1 &lt; v2 &#123;</div><div class="line">		stack.PushInt(-1)</div><div class="line">	&#125; else &#123;</div><div class="line">		stack.PushInt(-1)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-10-3-if指令"><a href="#3-10-3-if指令" class="headerlink" title="3.10.3 if指令"></a>3.10.3 if<cond>指令</cond></h5><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x99</td>
<td>ifeq</td>
<td>当栈顶int型数值等于0时跳转</td>
</tr>
<tr>
<td>0x9a</td>
<td>ifne</td>
<td>当栈顶int型数值不等于0时跳转</td>
</tr>
<tr>
<td>0x9b</td>
<td>iflt</td>
<td>当栈顶int型数值小于0时跳转</td>
</tr>
<tr>
<td>0x9c</td>
<td>ifge</td>
<td>当栈顶int型数值大于等于0时跳转</td>
</tr>
<tr>
<td>0x9d</td>
<td>ifgt</td>
<td>当栈顶int型数值大于0时跳转</td>
</tr>
<tr>
<td>0x9e</td>
<td>ifle</td>
<td>当栈顶int型数值小于等于0时跳转</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type IFEQ struct &#123;</div><div class="line">	base.BranchInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IFEQ) Execute(frame *rtda.Frame) &#123;</div><div class="line">	val := frame.OperandStack().PopInt()</div><div class="line">	if val == 0 &#123;</div><div class="line">		base.Branch(frame, self.Offset)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-10-4-if-icmp指令"><a href="#3-10-4-if-icmp指令" class="headerlink" title="3.10.4 if_icmp指令"></a>3.10.4 if_icmp<cond>指令</cond></h5><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x9f</td>
<td>if_icmpeq</td>
<td>比较栈顶两int型数值大小，当结果等于0时跳转</td>
</tr>
<tr>
<td>0xa0</td>
<td>if_icmpne</td>
<td>比较栈顶两int型数值大小，当结果不等于0时跳转</td>
</tr>
<tr>
<td>0xa1</td>
<td>if_icmplt</td>
<td>比较栈顶两int型数值大小，当结果小于0时跳转</td>
</tr>
<tr>
<td>0xa2</td>
<td>if_icmpge</td>
<td>比较栈顶两int型数值大小，当结果大于等于0时跳转</td>
</tr>
<tr>
<td>0xa3</td>
<td>if_icmpgt</td>
<td>比较栈顶两int型数值大小，当结果大于0时跳转</td>
</tr>
<tr>
<td>0xa4</td>
<td>if_icmple</td>
<td>比较栈顶两int型数值大小，当结果小于等于0时跳转</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type IF_ICMPEQ struct &#123;</div><div class="line">	base.BranchInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IF_ICMPEQ) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	v2 := stack.PopInt()</div><div class="line">	v1 := stack.PopInt()</div><div class="line">	if v1 == v2 &#123;</div><div class="line">		base.Branch(frame, self.Offset)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-10-5-if-acmp指令"><a href="#3-10-5-if-acmp指令" class="headerlink" title="3.10.5 if_acmp指令"></a>3.10.5 if_acmp<cond>指令</cond></h5><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xa5</td>
<td>if_acmpeq</td>
<td>比较栈顶两引用型数值，当结果相等时跳转</td>
</tr>
<tr>
<td>0xa6</td>
<td>if_acmpne</td>
<td>比较栈顶两引用型数值，当结果不相等时跳转</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type IF_ACMPEQ struct &#123;</div><div class="line">	base.BranchInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IF_ACMPEQ) Execute(frame *rtda.Frame) &#123;</div><div class="line">	stack := frame.OperandStack()</div><div class="line">	ref2 := stack.PopRef()</div><div class="line">	ref1 := stack.PopRef()</div><div class="line">	if ref1 == ref2 &#123;</div><div class="line">		base.Branch(frame, self.Offset)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-11-控制指令"><a href="#3-11-控制指令" class="headerlink" title="3.11 控制指令"></a>3.11 控制指令</h4><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xa7</td>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>0xa8</td>
<td>jsr</td>
<td>从jdk6开始已不再使用</td>
</tr>
<tr>
<td>0xa9</td>
<td>ret</td>
<td>从jdk6开始已不再使用</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type GOTO struct &#123;</div><div class="line">	base.BranchInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *GOTO) Execute(frame *rtda.Frame) &#123;</div><div class="line">	base.Branch(frame, self.Offset)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xaa</td>
<td>tableswitch</td>
<td>用于switch条件跳转，case值连续（可变长度指令）</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">type TABLE_SWITCH struct &#123;</div><div class="line">	defaultOffset int32</div><div class="line">	low           int32</div><div class="line">	high          int32</div><div class="line">	jumpOffsets   []int32</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *TABLE_SWITCH) FetchOperands(reader *base.ByteCodeReader) &#123;</div><div class="line">	reader.SkipPadding() // 操作码指令的后面有0-3字节的padding需要跳过</div><div class="line">	self.defaultOffset = reader.ReadInt32()</div><div class="line">	self.low = reader.ReadInt32()</div><div class="line">	self.high = reader.ReadInt32()</div><div class="line">	jumpOffsetsCount := self.high - self.low + 1</div><div class="line">	self.jumpOffsets = reader.ReadInt32s(jumpOffsetsCount)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *TABLE_SWITCH) Execute(frame *rtda.Frame) &#123;</div><div class="line">	index := frame.OperandStack().PopInt()</div><div class="line">	var offset int</div><div class="line">	if index &gt;= self.low &amp;&amp; index &lt;= self.high &#123;</div><div class="line">		offset = int(self.jumpOffsets[index-self.low])</div><div class="line">	&#125; else &#123;</div><div class="line">		offset = int(self.defaultOffset)</div><div class="line">	&#125;</div><div class="line">	base.Branch(frame, offset)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xab</td>
<td>lookupswitch</td>
<td>用于switch条件跳转，case值不连续（可变长度指令）</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">type LOOKUP_SWITCH struct &#123;</div><div class="line">	defaultOffset int32</div><div class="line">	npairs        int32</div><div class="line">	matchOffsets  []int32</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *LOOKUP_SWITCH) FetchOperands(reader *base.ByteCodeReader) &#123;</div><div class="line">	reader.SkipPadding()</div><div class="line">	self.defaultOffset = reader.ReadInt32()</div><div class="line">	self.npairs = reader.ReadInt32()</div><div class="line">	self.matchOffsets = reader.ReadInt32s(self.npairs * 2)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *LOOKUP_SWITCH) Execute(frame *rtda.Frame) &#123;</div><div class="line">	key := frame.OperandStack().PopInt()</div><div class="line">	for i := int32(0); i &lt; self.npairs*2; i += 2 &#123;</div><div class="line">		if self.matchOffsets[i] == key &#123;</div><div class="line">			offset := self.matchOffsets[i+1]</div><div class="line">			base.Branch(frame, int(offset))</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	base.Branch(frame, int(self.defaultOffset))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xac</td>
<td>ireturn</td>
<td>从当前方法返回int</td>
</tr>
<tr>
<td>0xad</td>
<td>lreturn</td>
<td>从当前方法返回long</td>
</tr>
<tr>
<td>0xae</td>
<td>freturn</td>
<td>从当前方法返回float</td>
</tr>
<tr>
<td>0xaf</td>
<td>dreturn</td>
<td>从当前方法返回double</td>
</tr>
<tr>
<td>0xb0</td>
<td>areturn</td>
<td>从当前方法返回对象引用</td>
</tr>
<tr>
<td>0xb1</td>
<td>return</td>
<td>从当前方法返回void</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type ARETURN struct&#123; base.NoOperandsInstruction &#125;</div><div class="line"></div><div class="line">func (self *ARETURN) Execute(frame *rtda.Frame) &#123;</div><div class="line">	thread := frame.Thread()</div><div class="line">	currentFrame := thread.PopFrame()</div><div class="line">	invokerFrame := thread.TopFrame()</div><div class="line">	ref := currentFrame.OperandStack().PopRef()</div><div class="line">	invokerFrame.OperandStack().PushRef(ref)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-12-引用指令"><a href="#3-12-引用指令" class="headerlink" title="3.12 引用指令"></a>3.12 引用指令</h4><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xb2</td>
<td>getstatic</td>
<td>获取指定类的静态域，并将其值压入栈顶</td>
</tr>
<tr>
<td>0xb3</td>
<td>putstatic</td>
<td>为指定的类的静态域赋值</td>
</tr>
<tr>
<td>0xb4</td>
<td>getfield</td>
<td>获取指定类的实例域，并将其值压入栈顶</td>
</tr>
<tr>
<td>0xb5</td>
<td>putfield</td>
<td>为指定的类的实例域赋值</td>
</tr>
<tr>
<td>0xb6</td>
<td>invokevirtual</td>
<td>调用实例方法</td>
</tr>
<tr>
<td>0xb7</td>
<td>invokespecial</td>
<td>调用超类构造方法，实例初始化方法，私有方法</td>
</tr>
<tr>
<td>0xb8</td>
<td>invokestatic</td>
<td>调用静态方法</td>
</tr>
<tr>
<td>0xb9</td>
<td>invokeinterface</td>
<td>调用接口方法</td>
</tr>
<tr>
<td>0xba</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>0xbb</td>
<td>new</td>
<td>创建一个对象，并将其引用值压入栈顶</td>
</tr>
<tr>
<td>0xbc</td>
<td>newarray</td>
<td>创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶</td>
</tr>
<tr>
<td>0xbd</td>
<td>anewarray</td>
<td>创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶</td>
</tr>
<tr>
<td>0xbe</td>
<td>arraylength</td>
<td>获得数组的长度值并压入栈顶</td>
</tr>
<tr>
<td>0xbf</td>
<td>athrow</td>
<td>将栈顶的异常抛出</td>
</tr>
<tr>
<td>0xc0</td>
<td>checkcast</td>
<td>检验类型转换，检验未通过将抛出ClassCastException</td>
</tr>
<tr>
<td>0xc1</td>
<td>instanceof</td>
<td>检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶</td>
</tr>
<tr>
<td>0xc2</td>
<td>monitorenter</td>
<td>获得对象的锁，用于同步方法或同步块</td>
</tr>
<tr>
<td>0xc3</td>
<td>monitorexit</td>
<td>释放对象的锁，用于同步方法或同步块</td>
</tr>
<tr>
<td>0xc4</td>
<td>wide</td>
<td>扩展指令index</td>
</tr>
<tr>
<td>0xc5</td>
<td>multianewarray</td>
<td>创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶</td>
</tr>
</tbody>
</table>
<h4 id="3-13-扩展指令"><a href="#3-13-扩展指令" class="headerlink" title="3.13 扩展指令"></a>3.13 扩展指令</h4><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xc6</td>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>0xc7</td>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type IFNULL struct &#123;</div><div class="line">	base.BranchInstruction</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *IFNULL) Execute(frame *rtda.Frame) &#123;</div><div class="line">	ref := frame.OperandStack().PopRef()</div><div class="line">	if ref == nil &#123;</div><div class="line">		base.Branch(frame, self.Offset)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xc8</td>
<td>goto_w</td>
<td>无条件跳转（宽索引）</td>
</tr>
<tr>
<td>0xc9</td>
<td>jsr_w</td>
<td>从jdk6开始已经不再使用</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type GOTO_W struct &#123;</div><div class="line">	offset int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *GOTO_W) FetchOperands(reader *base.ByteCodeReader) &#123;</div><div class="line">	self.offset = int(reader.ReadInt32())</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (self *GOTO_W) Execute(frame *rtda.Frame) &#123;</div><div class="line">	base.Branch(frame, self.offset)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-14-保留指令"><a href="#3-14-保留指令" class="headerlink" title="3.14 保留指令"></a>3.14 保留指令</h4><table>
<thead>
<tr>
<th>操作码</th>
<th>指令名</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xfe</td>
<td>invoke_native</td>
<td>调用native方法</td>
</tr>
</tbody>
</table>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
